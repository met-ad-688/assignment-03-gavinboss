---
title: Assignment 03 - AI Prompts
author:
  - name: Gavin Boss
    affiliations:
      - id: bu
        name: Boston University
        city: Boston
        state: MA
number-sections: true
date: '2025-09-20'
format:
  docx: default
  html:
    theme: cerulean
date-modified: today
date-format: long

---
# Appendix 1
::: {.callout-tip}
You're getting the same median salary across all ONET occupations because your `SALARY` column was overwritten with a constant value during data cleaning. Here's how to fix it step-by-step:
:::

:::{.callout-tip}
You're getting the same median salary across all ONET occupations because your `SALARY` column was overwritten with a constant value during data cleaning. Here's how to fix it step-by-step:

---

### ‚úÖ 1. **Avoid Overwriting SALARY with a Constant**

In your current code:

```python
df = df.fillna({
  "SALARY_FROM": median_from,
  "SALARY_TO": median_to
})

df = df.withColumn("SALARY", (col("SALARY_FROM") + col("SALARY_TO")) / 2)
```

This fills missing `SALARY_FROM` and `SALARY_TO` with the same median, so any row missing salary data ends up with the same computed value ‚Äî flattening the distribution.

---

### ‚úÖ 2. **Use Conditional Logic to Preserve Original SALARY**

Replace the overwrite with this:

```python
df = df.withColumn("SALARY", when(
    col("SALARY").isNotNull() & (col("SALARY") > 0),
    col("SALARY")
).otherwise((col("SALARY_FROM") + col("SALARY_TO")) / 2))
```

This keeps the original `SALARY` if it's valid, and only computes it when missing.

---

### ‚úÖ 3. **Double-Check Aggregation Logic**

Make sure you're grouping correctly and using `percentile_approx` with enough accuracy:

```python
agg_df = df.filter(
    col("SALARY").isNotNull() & (col("SALARY") > 0) &
    col("LOT_V6_SPECIALIZED_OCCUPATION_NAME").isNotNull() &
    (col("LOT_V6_SPECIALIZED_OCCUPATION_NAME") != "")
).groupBy("LOT_V6_SPECIALIZED_OCCUPATION_NAME") \
 .agg(
    expr("percentile_approx(SALARY, 0.5, 100)").alias("Median_Salary"),
    count("*").alias("Job_Postings")
).withColumnRenamed("LOT_V6_SPECIALIZED_OCCUPATION_NAME", "Occupation_Name")
```

If you still see duplicates, try increasing the accuracy:

```python
expr("percentile_approx(SALARY, 0.5, 1000)")
```

---

### ‚úÖ 4. **Validate SALARY Distribution Before Aggregating**

Run this to confirm variation:

```python
df.select("SALARY").distinct().show(20)
```

If you see only one or two values, the issue is upstream in your fill logic.

---

Once you fix the conditional logic, your bubble chart will reflect real differences in median salary across occupations. Let me know if you want to filter out low-volume occupations or sort by salary for a cleaner visual.
:::

# Appendix 2
:::{.callout-tip}
how do I fix a plot in px.scatter that is stacked vertically
:::

:::{.callout-tip}
If your px.scatter plot is stacked vertically, it usually means your x-axis values are discrete or repeated‚Äîlike integers or categories‚Äîso all the points with the same x-value align in vertical lines. Here's how to fix it:

‚úÖ Add Jitter to the X-Axis
This spreads the points horizontally so they cluster more naturally:
import numpy as np

# Add jitter to your x-axis column
df["x_jittered"] = df["your_x_column"] + np.random.uniform(-0.3, 0.3, size=len(df))

# Use the jittered column in your plot
fig = px.scatter(
    df,
    x="x_jittered",
    y="your_y_column",
    ...
)

Ó∑ôÓ∑ö
This works especially well if your x-values are integers like years of experience.

üß† Why It Happens
- If x = 1, 2, 3..., all points with x=1 stack vertically.
- Jitter breaks that up by nudging each point slightly left or right.

üõ† Optional Enhancements
- Add a trend line to show central tendency:
fig = px.scatter(..., trendline="ols")


- Use opacity to reveal dense areas:
fig.update_traces(opacity=0.6)


- Reduce marker size for better spacing:
fig.update_traces(marker=dict(size=6))



Let me know what your x-axis represents‚ÄîI can help you fine-tune the jitter or suggest alternatives like violin plots or density contours if clustering is key.
:::

:::{.callout-tip}
Appendix 3
Prompt: if I have all the data in a dataset, but want individual histographs using plotly how can i do that
:::

:::{.callout-tip}
To create individual histograms for each column in your dataset using Plotly, you can loop through the columns and generate a separate histogram for each one. Here's a clean and efficient way to do it using Plotly Express:
‚úÖ Example: Plotly Histograms for Each Column
import plotly.express as px
import pandas as pd

# Load your dataset
df = pd.read_csv('your_dataset.csv')  # or use any DataFrame

# Loop through each column and plot histogram
for col in df.select_dtypes(include='number').columns:
    fig = px.histogram(df, x=col, title=f'Histogram of {col}')
    fig.show()


üîç Notes:
- select_dtypes(include='number') ensures you only plot numeric columns.
- fig.show() will display each histogram one by one.
- You can customize bins, colors, and layout using additional parameters in px.histogram.
üõ† Optional Enhancements:
- If you're working in Quarto or Jupyter and want to save each plot:
fig.write_image(f"{col}_histogram.png")
- To display all histograms in one dashboard-like layout, consider using plotly.subplots.
Would you like help customizing bin sizes, colors, or exporting these for a report?
:::

:::{.callout-tip}
prompt: i have three colums, and already have it jittered
:::

:::{.callout-tip}
Perfect ‚Äî if you‚Äôve already jittered your data and want to create individual histograms for each of the three columns using Plotly, here‚Äôs how you can do it cleanly and efficiently:
‚úÖ Plotly Histograms for Jittered Columns
Assuming your DataFrame is called df and the three jittered columns are named col1, col2, and col3:
import plotly.express as px

# List of your jittered columns
columns = ['col1', 'col2', 'col3']

# Loop through each column and plot histogram
for col in columns:
    fig = px.histogram(df, x=col, title=f'Histogram of {col}', nbins=30)
    fig.update_layout(bargap=0.1)
    fig.show()


üîß Optional Enhancements:
- Customize bins: Use nbins=30 or adjust based on your data spread.
- Overlay KDE (density): Plotly doesn‚Äôt support KDE directly in px.histogram, but you can simulate it using go.Figure if needed.
- Color by category: If you have a categorical column like group, you can do:
fig = px.histogram(df, x=col, color='group', barmode='overlay')


üìä If You Want All Histograms in One Figure:
You can use make_subplots from plotly.subplots to stack them vertically or arrange them in a grid. Let me know if you want that layout and I‚Äôll show you how.
Would you like to export these as static images for your report or embed them in Quarto?
:::